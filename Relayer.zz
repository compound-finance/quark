object "Quark" {
  code {
    /** This is the init code (constructor) for
      * the Quark Relayer contract.
      *
      * This simply returns the Relayer code below.
      */
    datacopy(0, dataoffset("Relayer"), datasize("Relayer"))
    return(0, datasize("Relayer"))
  }

  object "Relayer" {
    /** This is the core Quark Relayer contract, which
      * is what users call into (the "to" address).
      *
      * The calldata pass in calls to this function will
      * be executed as Solidity code from a pre-determined
      * address (based on create2, but not on the contract
      * code itself).
      *
      * You can call this function as many times as you like,
      * and you will execute different code *from the same address*.
      *
      * Note: do not wrap your code in any Solidity contract or ABI
      *       encoding-- it should be the raw evm code to execute.
      *
      * Note: you currently need your code to self-destruct at the end
      *       in order to clean up. We hope to remove this constraint.
      *
      * Note: self-destruct is required for this trick to work, and
      *       may later be removed according to EIP-4758.
      */

    code {
      /**
        * First, we'll check if we're inside a Quark,
        *  - If yes, we'll return the current Quark code
        *  - If no, we'll run a new Quark execution
        *
        * This has the added benefit of preventing re-entry, though
        * we could soften this req. in the future.
        */

      // TODO: We should consider making this specific to a caller, but
      //       alternatively, we could enforce that caller must be an EOA to
      //       prevent having to think too hard about this.

      function running_quark() -> running {
        /** Returns if we're inside a quark,
          * which is defined as having the
          * quark size stored at storage slot 0.
          */
        running := gt(sload(0), 0)
      }

      function allocate(size) -> ptr {
        /** Allocates memory in a safe way. Returns a pointer to it.
          */
          ptr := mload(0x40)
          if iszero(ptr) { ptr := 0x60 }
          mstore(0x40, add(ptr, size))
      }

      function word_count(sz) -> words {
        /** This is 32-byte word count [rounding up]. For example,
          * word_count(5) == 1
          * word_count(32) == 1
          * word_count(33) == 2
          */
        words := div(sz, 32)
        if lt(mul(words, 32), sz) {
          words := add(words, 1)
        }
      }

      function load_quark() -> offset, quark_size {
        /** Loads the current quark from storage.
          * We store the quark size (in words) at
          * storage slot 0, and then the quark code
          * at storage slot 1+. This reassembles that
          * code into memory.
          */

        quark_size := sload(0)
        offset := allocate(quark_size)
        let quark_words := word_count(quark_size)
        for { let i := 0 } lt(i, quark_words) { i := add(i, 1) }
        {
          mstore(add(offset, mul(i, 32)), sload(add(i, 1)))
        }
      }

      function store_quark(offset, quark_size) {
        /** Stores a quark from memory into storage.
          * See `load_quark` for more information.
          */

        sstore(0, quark_size)
        let quark_words := word_count(quark_size)
        for { let i := 0 } lt(i, quark_words) { i := add(i, 1) }
        {
          let word := mload(add(offset, mul(i, 32)))
          sstore(add(i, 1), word)
        }
      }

      function clear_quark(quark_size) {
        /** Clear quark from storage, reclaiming
          * gas since we zero out data in same trx.
          */

        let quark_words := word_count(quark_size)
        for { let i := 0 } lt(i, quark_words) { i := add(i, 1) }
        {
          sstore(add(i, 1), 0)
        }
        sstore(0, 0)
      }

      function selector() -> s {
        s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
      }

      function decode_as_address(offset) -> v {
        v := decode_as_uint(offset)
        if iszero(iszero(and(v, not(0xffffffffffffffffffffffffffffffffffffffff)))) {
          revert(0, 0)
        }
      }
      
      function decode_as_uint(offset) -> v {
        let pos := add(4, mul(offset, 0x20))
        if lt(calldatasize(), add(pos, 0x20)) {
            revert(0, 0)
        }
        v := calldataload(pos)
      }

      function revert_err(offset, size) {
        datacopy(0, offset, size)
        revert(0, size)
      }

      switch running_quark()
      case true {
        /** If we're in a running quark, simply return
          * the code for the quark.

          * Note: this is used by the Virtual contract
          *       below to get the quark data since we
          *       can't pass it to Virtual since it would
          *       change the data passed to `create2` and
          *       thus change the created contract address
          *       each time.
          */
        let offset, size := load_quark()
        return(offset, size)
      }
      case false {
        /** First check for some helpful function calls. These are guaranteed to be invalid bytecode
          * as they all must start with 0xfe which is the "invalid" code.
          */

        switch selector()
        case 0xfe5a936a /* "quarkAddress25(address)(address)" */ {
          // Note: we can share this code if we want, but I'd rather copy it

          // Track the caller (TODO: Take this as an arg?)
          let account := decode_as_address(0)

          // Load the Virtual contract data
          let virt_size := datasize("Virtual")
          let virt_offset := allocate(add(virt_size, 32))
          datacopy(virt_offset, dataoffset("Virtual"), virt_size)

          // Add the caller to the init code [Note: we *want* this to be part of the create2 derivation path]
          mstore(add(virt_offset, virt_size), account)

          let code_hash := keccak256(virt_offset, add(virt_size, 32))

          // keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]

          // 0x01 + 0x14 + 0x20 + 0x20 = 0x55
          let derivation := allocate(0x55)
          mstore8(derivation, 0xFF)                           // 00-01: 0xFF
          mstore(add(derivation, 0x01), shl(96, address()))   // 01-15: {address}
          mstore(add(derivation, 0x15), 0)                    // 15-35: {salt}
          mstore(add(derivation, 0x35), code_hash)            // 35-55: {sha3(init)}

          let addr := and(keccak256(derivation, 0x55), 0xffffffffffffffffffffffffffffffffffffffff)

          let res := allocate(32)
          mstore(res, addr)

          return(res, 32)
        }
        case 0xfee6f038 /* "virtualCode81()(bytes)" */ {
          // Load the Virtual contract data
          let virt_size := datasize("Virtual")
          let virt_offset := allocate(add(virt_size, 64))

          mstore(virt_offset, 0x20)
          mstore(add(virt_offset, 32), virt_size)
          datacopy(add(virt_offset, 64), dataoffset("Virtual"), virt_size)

          return(virt_offset, add(virt_size, 64))
        }
        default {
          /** Start a new quark environment.
            * First, we'll store the quark data in storage (to make
            * it available for the Virtual contract's init code).
            *
            * Next, we'll deploy (via create2) the Virtual contract,
            * which will call back into this contract to get the init
            * code for that contract (and return it directly).
            *
            * Finally, we'll clean up storage and get the Virtual
            * contract to self destruct.
            */

          // Track the caller
          let account := caller()

          // Store the quark code
          let quark_size := calldatasize()
          let quark_offset := allocate(quark_size)
          calldatacopy(quark_offset, 0, quark_size)
          store_quark(quark_offset, quark_size)

          // Load the Virtual contract data
          let virt_size := datasize("Virtual")
          let virt_offset := allocate(add(virt_size, 32))
          datacopy(virt_offset, dataoffset("Virtual"), virt_size)

          // Add the caller to the init code [Note: we *want* this to be part of the create2 derivation path]
          mstore(add(virt_offset, virt_size), account)

          // Deploy the Virtual contract
          let virt := create2(0, virt_offset, add(virt_size, 32), 0)

          // Clear the quark code (to reclaim gas)
          clear_quark(quark_size)

          // Ensure the contract was created, and if not, bail
          if iszero(extcodesize(virt)) {
            revert_err(dataoffset("Create2Failed"), datasize("Create2Failed"))
          }

          // Invoke the newly deployed virtual contract (i.e. run the user-supplied code)
          let succ := call(gas(), virt, 0, 0, 0, 0, 0)

          if iszero(succ) {
            revert_err(dataoffset("InvocationFailure"), datasize("InvocationFailure"))
          }

          // Self-destruct the Virtual contract by calling it again
          succ := call(gas(), virt, 0, 0, 0, 0, 0)

          if iszero(succ) {
            revert_err(dataoffset("CleanupFailure"), datasize("CleanupFailure"))
          }

          // We don't return any meaningful value,
          // though we could pass back the result
          // of the function call.
          return(0, 0)
        }
      }
    }

    data "Create2Failed" hex"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e43726561746532206661696c6564000000000000000000000000000000000000"
    data "InvocationFailure" hex"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001b436f6e747261637420496e766f636174696f6e204661696c7572650000000000"
    data "CleanupFailure" hex"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000018436f6e747261637420436c65616e7570204661696c7572650000000000000000"
}
